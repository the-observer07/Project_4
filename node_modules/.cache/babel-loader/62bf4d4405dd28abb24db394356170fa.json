{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/inspireadmin/Documents/GitHub/Project_2/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _classCallCheck = require(\"/Users/inspireadmin/Documents/GitHub/Project_2/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/inspireadmin/Documents/GitHub/Project_2/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nvar BottleneckError, LocalDatastore, parser;\nparser = require(\"./parser\");\nBottleneckError = require(\"./BottleneckError\");\n\nLocalDatastore = /*#__PURE__*/function () {\n  function LocalDatastore(instance, storeOptions, storeInstanceOptions) {\n    _classCallCheck(this, LocalDatastore);\n\n    this.instance = instance;\n    this.storeOptions = storeOptions;\n    this.clientId = this.instance._randomIndex();\n    parser.load(storeInstanceOptions, storeInstanceOptions, this);\n    this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();\n    this._running = 0;\n    this._done = 0;\n    this._unblockTime = 0;\n    this.ready = this.Promise.resolve();\n    this.clients = {};\n\n    this._startHeartbeat();\n  }\n\n  _createClass(LocalDatastore, [{\n    key: \"_startHeartbeat\",\n    value: function _startHeartbeat() {\n      var _this14 = this;\n\n      var base;\n\n      if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {\n        return typeof (base = this.heartbeat = setInterval(function () {\n          var amount, incr, maximum, now, reservoir;\n          now = Date.now();\n\n          if (_this14.storeOptions.reservoirRefreshInterval != null && now >= _this14._lastReservoirRefresh + _this14.storeOptions.reservoirRefreshInterval) {\n            _this14._lastReservoirRefresh = now;\n            _this14.storeOptions.reservoir = _this14.storeOptions.reservoirRefreshAmount;\n\n            _this14.instance._drainAll(_this14.computeCapacity());\n          }\n\n          if (_this14.storeOptions.reservoirIncreaseInterval != null && now >= _this14._lastReservoirIncrease + _this14.storeOptions.reservoirIncreaseInterval) {\n            var _this$storeOptions = _this14.storeOptions;\n            amount = _this$storeOptions.reservoirIncreaseAmount;\n            maximum = _this$storeOptions.reservoirIncreaseMaximum;\n            reservoir = _this$storeOptions.reservoir;\n            _this14._lastReservoirIncrease = now;\n            incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;\n\n            if (incr > 0) {\n              _this14.storeOptions.reservoir += incr;\n              return _this14.instance._drainAll(_this14.computeCapacity());\n            }\n          }\n        }, this.heartbeatInterval)).unref === \"function\" ? base.unref() : void 0;\n      } else {\n        return clearInterval(this.heartbeat);\n      }\n    }\n  }, {\n    key: \"__publish__\",\n    value: function __publish__(message) {\n      var _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _this.yieldLoop();\n\n              case 2:\n                return _context.abrupt(\"return\", _this.instance.Events.trigger(\"message\", message.toString()));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    }\n  }, {\n    key: \"__disconnect__\",\n    value: function __disconnect__(flush) {\n      var _this2 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return _this2.yieldLoop();\n\n              case 2:\n                clearInterval(_this2.heartbeat);\n                return _context2.abrupt(\"return\", _this2.Promise.resolve());\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    }\n  }, {\n    key: \"yieldLoop\",\n    value: function yieldLoop() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return new this.Promise(function (resolve, reject) {\n        return setTimeout(resolve, t);\n      });\n    }\n  }, {\n    key: \"computePenalty\",\n    value: function computePenalty() {\n      var ref;\n      return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5000;\n    }\n  }, {\n    key: \"__updateSettings__\",\n    value: function __updateSettings__(options) {\n      var _this3 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return _this3.yieldLoop();\n\n              case 2:\n                parser.overwrite(options, options, _this3.storeOptions);\n\n                _this3._startHeartbeat();\n\n                _this3.instance._drainAll(_this3.computeCapacity());\n\n                return _context3.abrupt(\"return\", true);\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    }\n  }, {\n    key: \"__running__\",\n    value: function __running__() {\n      var _this4 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return _this4.yieldLoop();\n\n              case 2:\n                return _context4.abrupt(\"return\", _this4._running);\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }))();\n    }\n  }, {\n    key: \"__queued__\",\n    value: function __queued__() {\n      var _this5 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return _this5.yieldLoop();\n\n              case 2:\n                return _context5.abrupt(\"return\", _this5.instance.queued());\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    }\n  }, {\n    key: \"__done__\",\n    value: function __done__() {\n      var _this6 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return _this6.yieldLoop();\n\n              case 2:\n                return _context6.abrupt(\"return\", _this6._done);\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }))();\n    }\n  }, {\n    key: \"__groupCheck__\",\n    value: function __groupCheck__(time) {\n      var _this7 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return _this7.yieldLoop();\n\n              case 2:\n                return _context7.abrupt(\"return\", _this7._nextRequest + _this7.timeout < time);\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }))();\n    }\n  }, {\n    key: \"computeCapacity\",\n    value: function computeCapacity() {\n      var maxConcurrent, reservoir;\n      var _this$storeOptions2 = this.storeOptions;\n      maxConcurrent = _this$storeOptions2.maxConcurrent;\n      reservoir = _this$storeOptions2.reservoir;\n\n      if (maxConcurrent != null && reservoir != null) {\n        return Math.min(maxConcurrent - this._running, reservoir);\n      } else if (maxConcurrent != null) {\n        return maxConcurrent - this._running;\n      } else if (reservoir != null) {\n        return reservoir;\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"conditionsCheck\",\n    value: function conditionsCheck(weight) {\n      var capacity;\n      capacity = this.computeCapacity();\n      return capacity == null || weight <= capacity;\n    }\n  }, {\n    key: \"__incrementReservoir__\",\n    value: function __incrementReservoir__(incr) {\n      var _this8 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var reservoir;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return _this8.yieldLoop();\n\n              case 2:\n                reservoir = _this8.storeOptions.reservoir += incr;\n\n                _this8.instance._drainAll(_this8.computeCapacity());\n\n                return _context8.abrupt(\"return\", reservoir);\n\n              case 5:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }))();\n    }\n  }, {\n    key: \"__currentReservoir__\",\n    value: function __currentReservoir__() {\n      var _this9 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return _this9.yieldLoop();\n\n              case 2:\n                return _context9.abrupt(\"return\", _this9.storeOptions.reservoir);\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }))();\n    }\n  }, {\n    key: \"isBlocked\",\n    value: function isBlocked(now) {\n      return this._unblockTime >= now;\n    }\n  }, {\n    key: \"check\",\n    value: function check(weight, now) {\n      return this.conditionsCheck(weight) && this._nextRequest - now <= 0;\n    }\n  }, {\n    key: \"__check__\",\n    value: function __check__(weight) {\n      var _this10 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var now;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return _this10.yieldLoop();\n\n              case 2:\n                now = Date.now();\n                return _context10.abrupt(\"return\", _this10.check(weight, now));\n\n              case 4:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }))();\n    }\n  }, {\n    key: \"__register__\",\n    value: function __register__(index, weight, expiration) {\n      var _this11 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n        var now, wait;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return _this11.yieldLoop();\n\n              case 2:\n                now = Date.now();\n\n                if (!_this11.conditionsCheck(weight)) {\n                  _context11.next = 11;\n                  break;\n                }\n\n                _this11._running += weight;\n\n                if (_this11.storeOptions.reservoir != null) {\n                  _this11.storeOptions.reservoir -= weight;\n                }\n\n                wait = Math.max(_this11._nextRequest - now, 0);\n                _this11._nextRequest = now + wait + _this11.storeOptions.minTime;\n                return _context11.abrupt(\"return\", {\n                  success: true,\n                  wait: wait,\n                  reservoir: _this11.storeOptions.reservoir\n                });\n\n              case 11:\n                return _context11.abrupt(\"return\", {\n                  success: false\n                });\n\n              case 12:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }))();\n    }\n  }, {\n    key: \"strategyIsBlock\",\n    value: function strategyIsBlock() {\n      return this.storeOptions.strategy === 3;\n    }\n  }, {\n    key: \"__submit__\",\n    value: function __submit__(queueLength, weight) {\n      var _this12 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var blocked, now, reachedHWM;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return _this12.yieldLoop();\n\n              case 2:\n                if (!(_this12.storeOptions.maxConcurrent != null && weight > _this12.storeOptions.maxConcurrent)) {\n                  _context12.next = 4;\n                  break;\n                }\n\n                throw new BottleneckError(\"Impossible to add a job having a weight of \".concat(weight, \" to a limiter having a maxConcurrent setting of \").concat(_this12.storeOptions.maxConcurrent));\n\n              case 4:\n                now = Date.now();\n                reachedHWM = _this12.storeOptions.highWater != null && queueLength === _this12.storeOptions.highWater && !_this12.check(weight, now);\n                blocked = _this12.strategyIsBlock() && (reachedHWM || _this12.isBlocked(now));\n\n                if (blocked) {\n                  _this12._unblockTime = now + _this12.computePenalty();\n                  _this12._nextRequest = _this12._unblockTime + _this12.storeOptions.minTime;\n\n                  _this12.instance._dropAllQueued();\n                }\n\n                return _context12.abrupt(\"return\", {\n                  reachedHWM: reachedHWM,\n                  blocked: blocked,\n                  strategy: _this12.storeOptions.strategy\n                });\n\n              case 9:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12);\n      }))();\n    }\n  }, {\n    key: \"__free__\",\n    value: function __free__(index, weight) {\n      var _this13 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return _this13.yieldLoop();\n\n              case 2:\n                _this13._running -= weight;\n                _this13._done += weight;\n\n                _this13.instance._drainAll(_this13.computeCapacity());\n\n                return _context13.abrupt(\"return\", {\n                  running: _this13._running\n                });\n\n              case 6:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13);\n      }))();\n    }\n  }]);\n\n  return LocalDatastore;\n}();\n\nmodule.exports = LocalDatastore;","map":{"version":3,"sources":["/Users/inspireadmin/Documents/GitHub/Project_2/node_modules/bottleneck/lib/LocalDatastore.js"],"names":["asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","_asyncToGenerator","fn","self","args","arguments","apply","err","undefined","BottleneckError","LocalDatastore","parser","require","instance","storeOptions","storeInstanceOptions","clientId","_randomIndex","load","_nextRequest","_lastReservoirRefresh","_lastReservoirIncrease","Date","now","_running","_done","_unblockTime","ready","clients","_startHeartbeat","base","heartbeat","reservoirRefreshInterval","reservoirRefreshAmount","reservoirIncreaseInterval","reservoirIncreaseAmount","setInterval","amount","incr","maximum","reservoir","_drainAll","computeCapacity","_this$storeOptions","reservoirIncreaseMaximum","Math","min","heartbeatInterval","unref","clearInterval","message","_this","yieldLoop","Events","trigger","toString","flush","_this2","t","setTimeout","ref","penalty","minTime","options","_this3","overwrite","_this4","_this5","queued","_this6","time","_this7","timeout","maxConcurrent","_this$storeOptions2","weight","capacity","_this8","_this9","conditionsCheck","_this10","check","index","expiration","_this11","wait","max","success","strategy","queueLength","_this12","reachedHWM","highWater","blocked","strategyIsBlock","isBlocked","computePenalty","_dropAllQueued","_this13","running","module","exports"],"mappings":"AAAA;;;;;;;;AAEA,SAASA,kBAAT,CAA4BC,GAA5B,EAAiCC,OAAjC,EAA0CC,MAA1C,EAAkDC,KAAlD,EAAyDC,MAAzD,EAAiEC,GAAjE,EAAsEC,GAAtE,EAA2E;AAAE,MAAI;AAAE,QAAIC,IAAI,GAAGP,GAAG,CAACK,GAAD,CAAH,CAASC,GAAT,CAAX;AAA0B,QAAIE,KAAK,GAAGD,IAAI,CAACC,KAAjB;AAAyB,GAAzD,CAA0D,OAAOC,KAAP,EAAc;AAAEP,IAAAA,MAAM,CAACO,KAAD,CAAN;AAAe;AAAS;;AAAC,MAAIF,IAAI,CAACG,IAAT,EAAe;AAAET,IAAAA,OAAO,CAACO,KAAD,CAAP;AAAiB,GAAlC,MAAwC;AAAEG,IAAAA,OAAO,CAACV,OAAR,CAAgBO,KAAhB,EAAuBI,IAAvB,CAA4BT,KAA5B,EAAmCC,MAAnC;AAA6C;AAAE;;AAEzQ,SAASS,iBAAT,CAA2BC,EAA3B,EAA+B;AAAE,SAAO,YAAY;AAAE,QAAIC,IAAI,GAAG,IAAX;AAAA,QAAiBC,IAAI,GAAGC,SAAxB;AAAmC,WAAO,IAAIN,OAAJ,CAAY,UAAUV,OAAV,EAAmBC,MAAnB,EAA2B;AAAE,UAAIF,GAAG,GAAGc,EAAE,CAACI,KAAH,CAASH,IAAT,EAAeC,IAAf,CAAV;;AAAgC,eAASb,KAAT,CAAeK,KAAf,EAAsB;AAAET,QAAAA,kBAAkB,CAACC,GAAD,EAAMC,OAAN,EAAeC,MAAf,EAAuBC,KAAvB,EAA8BC,MAA9B,EAAsC,MAAtC,EAA8CI,KAA9C,CAAlB;AAAyE;;AAAC,eAASJ,MAAT,CAAgBe,GAAhB,EAAqB;AAAEpB,QAAAA,kBAAkB,CAACC,GAAD,EAAMC,OAAN,EAAeC,MAAf,EAAuBC,KAAvB,EAA8BC,MAA9B,EAAsC,OAAtC,EAA+Ce,GAA/C,CAAlB;AAAwE;;AAAChB,MAAAA,KAAK,CAACiB,SAAD,CAAL;AAAmB,KAA9R,CAAP;AAAyS,GAAjW;AAAoW;;AAErY,IAAIC,eAAJ,EAAqBC,cAArB,EAAqCC,MAArC;AACAA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAAhB;AACAH,eAAe,GAAGG,OAAO,CAAC,mBAAD,CAAzB;;AACAF,cAAc;AACZ,0BAAYG,QAAZ,EAAsBC,YAAtB,EAAoCC,oBAApC,EAA0D;AAAA;;AACxD,SAAKF,QAAL,GAAgBA,QAAhB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKE,QAAL,GAAgB,KAAKH,QAAL,CAAcI,YAAd,EAAhB;AACAN,IAAAA,MAAM,CAACO,IAAP,CAAYH,oBAAZ,EAAkCA,oBAAlC,EAAwD,IAAxD;AACA,SAAKI,YAAL,GAAoB,KAAKC,qBAAL,GAA6B,KAAKC,sBAAL,GAA8BC,IAAI,CAACC,GAAL,EAA/E;AACA,SAAKC,QAAL,GAAgB,CAAhB;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,YAAL,GAAoB,CAApB;AACA,SAAKC,KAAL,GAAa,KAAK5B,OAAL,CAAaV,OAAb,EAAb;AACA,SAAKuC,OAAL,GAAe,EAAf;;AAEA,SAAKC,eAAL;AACD;;AAdW;AAAA;AAAA,WAgBZ,2BAAkB;AAAA;;AAChB,UAAIC,IAAJ;;AAEA,UAAI,KAAKC,SAAL,IAAkB,IAAlB,KAA2B,KAAKjB,YAAL,CAAkBkB,wBAAlB,IAA8C,IAA9C,IAAsD,KAAKlB,YAAL,CAAkBmB,sBAAlB,IAA4C,IAAlG,IAA0G,KAAKnB,YAAL,CAAkBoB,yBAAlB,IAA+C,IAA/C,IAAuD,KAAKpB,YAAL,CAAkBqB,uBAAlB,IAA6C,IAAzO,CAAJ,EAAoP;AAClP,eAAO,OAAO,CAACL,IAAI,GAAG,KAAKC,SAAL,GAAiBK,WAAW,CAAC,YAAM;AACvD,cAAIC,MAAJ,EAAYC,IAAZ,EAAkBC,OAAlB,EAA2BhB,GAA3B,EAAgCiB,SAAhC;AACAjB,UAAAA,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAN;;AAEA,cAAI,OAAI,CAACT,YAAL,CAAkBkB,wBAAlB,IAA8C,IAA9C,IAAsDT,GAAG,IAAI,OAAI,CAACH,qBAAL,GAA6B,OAAI,CAACN,YAAL,CAAkBkB,wBAAhH,EAA0I;AACxI,YAAA,OAAI,CAACZ,qBAAL,GAA6BG,GAA7B;AACA,YAAA,OAAI,CAACT,YAAL,CAAkB0B,SAAlB,GAA8B,OAAI,CAAC1B,YAAL,CAAkBmB,sBAAhD;;AAEA,YAAA,OAAI,CAACpB,QAAL,CAAc4B,SAAd,CAAwB,OAAI,CAACC,eAAL,EAAxB;AACD;;AAED,cAAI,OAAI,CAAC5B,YAAL,CAAkBoB,yBAAlB,IAA+C,IAA/C,IAAuDX,GAAG,IAAI,OAAI,CAACF,sBAAL,GAA8B,OAAI,CAACP,YAAL,CAAkBoB,yBAAlH,EAA6I;AAC3I,gBAAIS,kBAAkB,GAAG,OAAI,CAAC7B,YAA9B;AACAuB,YAAAA,MAAM,GAAGM,kBAAkB,CAACR,uBAA5B;AACAI,YAAAA,OAAO,GAAGI,kBAAkB,CAACC,wBAA7B;AACAJ,YAAAA,SAAS,GAAGG,kBAAkB,CAACH,SAA/B;AACA,YAAA,OAAI,CAACnB,sBAAL,GAA8BE,GAA9B;AACAe,YAAAA,IAAI,GAAGC,OAAO,IAAI,IAAX,GAAkBM,IAAI,CAACC,GAAL,CAAST,MAAT,EAAiBE,OAAO,GAAGC,SAA3B,CAAlB,GAA0DH,MAAjE;;AAEA,gBAAIC,IAAI,GAAG,CAAX,EAAc;AACZ,cAAA,OAAI,CAACxB,YAAL,CAAkB0B,SAAlB,IAA+BF,IAA/B;AACA,qBAAO,OAAI,CAACzB,QAAL,CAAc4B,SAAd,CAAwB,OAAI,CAACC,eAAL,EAAxB,CAAP;AACD;AACF;AACF,SAxBiD,EAwB/C,KAAKK,iBAxB0C,CAApC,EAwBcC,KAxBrB,KAwB+B,UAxB/B,GAwB4ClB,IAAI,CAACkB,KAAL,EAxB5C,GAwB2D,KAAK,CAxBvE;AAyBD,OA1BD,MA0BO;AACL,eAAOC,aAAa,CAAC,KAAKlB,SAAN,CAApB;AACD;AACF;AAhDW;AAAA;AAAA,WAkDZ,qBAAYmB,OAAZ,EAAqB;AACnB,UAAIC,KAAK,GAAG,IAAZ;;AAEA,aAAOlD,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AACvB,uBAAMkD,KAAK,CAACC,SAAN,EAAN;;AADuB;AAAA,iDAEhBD,KAAK,CAACtC,QAAN,CAAewC,MAAf,CAAsBC,OAAtB,CAA8B,SAA9B,EAAyCJ,OAAO,CAACK,QAAR,EAAzC,CAFgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AAID;AAzDW;AAAA;AAAA,WA2DZ,wBAAeC,KAAf,EAAsB;AACpB,UAAIC,MAAM,GAAG,IAAb;;AAEA,aAAOxD,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AACvB,uBAAMwD,MAAM,CAACL,SAAP,EAAN;;AADuB;AAEvBH,gBAAAA,aAAa,CAACQ,MAAM,CAAC1B,SAAR,CAAb;AAFuB,kDAGhB0B,MAAM,CAAC1D,OAAP,CAAeV,OAAf,EAHgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AAKD;AAnEW;AAAA;AAAA,WAqEZ,qBAAiB;AAAA,UAAPqE,CAAO,uEAAH,CAAG;AACf,aAAO,IAAI,KAAK3D,OAAT,CAAiB,UAAUV,OAAV,EAAmBC,MAAnB,EAA2B;AACjD,eAAOqE,UAAU,CAACtE,OAAD,EAAUqE,CAAV,CAAjB;AACD,OAFM,CAAP;AAGD;AAzEW;AAAA;AAAA,WA2EZ,0BAAiB;AACf,UAAIE,GAAJ;AACA,aAAO,CAACA,GAAG,GAAG,KAAK9C,YAAL,CAAkB+C,OAAzB,KAAqC,IAArC,GAA4CD,GAA5C,GAAkD,KAAK,KAAK9C,YAAL,CAAkBgD,OAAvB,IAAkC,IAA3F;AACD;AA9EW;AAAA;AAAA,WAgFZ,4BAAmBC,OAAnB,EAA4B;AAC1B,UAAIC,MAAM,GAAG,IAAb;;AAEA,aAAO/D,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AACvB,uBAAM+D,MAAM,CAACZ,SAAP,EAAN;;AADuB;AAEvBzC,gBAAAA,MAAM,CAACsD,SAAP,CAAiBF,OAAjB,EAA0BA,OAA1B,EAAmCC,MAAM,CAAClD,YAA1C;;AAEAkD,gBAAAA,MAAM,CAACnC,eAAP;;AAEAmC,gBAAAA,MAAM,CAACnD,QAAP,CAAgB4B,SAAhB,CAA0BuB,MAAM,CAACtB,eAAP,EAA1B;;AANuB,kDAQhB,IARgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AAUD;AA7FW;AAAA;AAAA,WA+FZ,uBAAc;AACZ,UAAIwB,MAAM,GAAG,IAAb;;AAEA,aAAOjE,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AACvB,uBAAMiE,MAAM,CAACd,SAAP,EAAN;;AADuB;AAAA,kDAEhBc,MAAM,CAAC1C,QAFS;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AAID;AAtGW;AAAA;AAAA,WAwGZ,sBAAa;AACX,UAAI2C,MAAM,GAAG,IAAb;;AAEA,aAAOlE,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AACvB,uBAAMkE,MAAM,CAACf,SAAP,EAAN;;AADuB;AAAA,kDAEhBe,MAAM,CAACtD,QAAP,CAAgBuD,MAAhB,EAFgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AAID;AA/GW;AAAA;AAAA,WAiHZ,oBAAW;AACT,UAAIC,MAAM,GAAG,IAAb;;AAEA,aAAOpE,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AACvB,uBAAMoE,MAAM,CAACjB,SAAP,EAAN;;AADuB;AAAA,kDAEhBiB,MAAM,CAAC5C,KAFS;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AAID;AAxHW;AAAA;AAAA,WA0HZ,wBAAe6C,IAAf,EAAqB;AACnB,UAAIC,MAAM,GAAG,IAAb;;AAEA,aAAOtE,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AACvB,uBAAMsE,MAAM,CAACnB,SAAP,EAAN;;AADuB;AAAA,kDAEhBmB,MAAM,CAACpD,YAAP,GAAsBoD,MAAM,CAACC,OAA7B,GAAuCF,IAFvB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AAID;AAjIW;AAAA;AAAA,WAmIZ,2BAAkB;AAChB,UAAIG,aAAJ,EAAmBjC,SAAnB;AACA,UAAIkC,mBAAmB,GAAG,KAAK5D,YAA/B;AACA2D,MAAAA,aAAa,GAAGC,mBAAmB,CAACD,aAApC;AACAjC,MAAAA,SAAS,GAAGkC,mBAAmB,CAAClC,SAAhC;;AAEA,UAAIiC,aAAa,IAAI,IAAjB,IAAyBjC,SAAS,IAAI,IAA1C,EAAgD;AAC9C,eAAOK,IAAI,CAACC,GAAL,CAAS2B,aAAa,GAAG,KAAKjD,QAA9B,EAAwCgB,SAAxC,CAAP;AACD,OAFD,MAEO,IAAIiC,aAAa,IAAI,IAArB,EAA2B;AAChC,eAAOA,aAAa,GAAG,KAAKjD,QAA5B;AACD,OAFM,MAEA,IAAIgB,SAAS,IAAI,IAAjB,EAAuB;AAC5B,eAAOA,SAAP;AACD,OAFM,MAEA;AACL,eAAO,IAAP;AACD;AACF;AAlJW;AAAA;AAAA,WAoJZ,yBAAgBmC,MAAhB,EAAwB;AACtB,UAAIC,QAAJ;AACAA,MAAAA,QAAQ,GAAG,KAAKlC,eAAL,EAAX;AACA,aAAOkC,QAAQ,IAAI,IAAZ,IAAoBD,MAAM,IAAIC,QAArC;AACD;AAxJW;AAAA;AAAA,WA0JZ,gCAAuBtC,IAAvB,EAA6B;AAC3B,UAAIuC,MAAM,GAAG,IAAb;;AAEA,aAAO5E,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEvB,uBAAM4E,MAAM,CAACzB,SAAP,EAAN;;AAFuB;AAGvBZ,gBAAAA,SAAS,GAAGqC,MAAM,CAAC/D,YAAP,CAAoB0B,SAApB,IAAiCF,IAA7C;;AAEAuC,gBAAAA,MAAM,CAAChE,QAAP,CAAgB4B,SAAhB,CAA0BoC,MAAM,CAACnC,eAAP,EAA1B;;AALuB,kDAOhBF,SAPgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AASD;AAtKW;AAAA;AAAA,WAwKZ,gCAAuB;AACrB,UAAIsC,MAAM,GAAG,IAAb;;AAEA,aAAO7E,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AACvB,uBAAM6E,MAAM,CAAC1B,SAAP,EAAN;;AADuB;AAAA,kDAEhB0B,MAAM,CAAChE,YAAP,CAAoB0B,SAFJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AAID;AA/KW;AAAA;AAAA,WAiLZ,mBAAUjB,GAAV,EAAe;AACb,aAAO,KAAKG,YAAL,IAAqBH,GAA5B;AACD;AAnLW;AAAA;AAAA,WAqLZ,eAAMoD,MAAN,EAAcpD,GAAd,EAAmB;AACjB,aAAO,KAAKwD,eAAL,CAAqBJ,MAArB,KAAgC,KAAKxD,YAAL,GAAoBI,GAApB,IAA2B,CAAlE;AACD;AAvLW;AAAA;AAAA,WAyLZ,mBAAUoD,MAAV,EAAkB;AAChB,UAAIK,OAAO,GAAG,IAAd;;AAEA,aAAO/E,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEvB,uBAAM+E,OAAO,CAAC5B,SAAR,EAAN;;AAFuB;AAGvB7B,gBAAAA,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAN;AAHuB,mDAIhByD,OAAO,CAACC,KAAR,CAAcN,MAAd,EAAsBpD,GAAtB,CAJgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AAMD;AAlMW;AAAA;AAAA,WAoMZ,sBAAa2D,KAAb,EAAoBP,MAApB,EAA4BQ,UAA5B,EAAwC;AACtC,UAAIC,OAAO,GAAG,IAAd;;AAEA,aAAOnF,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEvB,uBAAMmF,OAAO,CAAChC,SAAR,EAAN;;AAFuB;AAGvB7B,gBAAAA,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAN;;AAHuB,qBAKnB6D,OAAO,CAACL,eAAR,CAAwBJ,MAAxB,CALmB;AAAA;AAAA;AAAA;;AAMrBS,gBAAAA,OAAO,CAAC5D,QAAR,IAAoBmD,MAApB;;AAEA,oBAAIS,OAAO,CAACtE,YAAR,CAAqB0B,SAArB,IAAkC,IAAtC,EAA4C;AAC1C4C,kBAAAA,OAAO,CAACtE,YAAR,CAAqB0B,SAArB,IAAkCmC,MAAlC;AACD;;AAEDU,gBAAAA,IAAI,GAAGxC,IAAI,CAACyC,GAAL,CAASF,OAAO,CAACjE,YAAR,GAAuBI,GAAhC,EAAqC,CAArC,CAAP;AACA6D,gBAAAA,OAAO,CAACjE,YAAR,GAAuBI,GAAG,GAAG8D,IAAN,GAAaD,OAAO,CAACtE,YAAR,CAAqBgD,OAAzD;AAbqB,mDAcd;AACLyB,kBAAAA,OAAO,EAAE,IADJ;AAELF,kBAAAA,IAAI,EAAJA,IAFK;AAGL7C,kBAAAA,SAAS,EAAE4C,OAAO,CAACtE,YAAR,CAAqB0B;AAH3B,iBAdc;;AAAA;AAAA,mDAoBd;AACL+C,kBAAAA,OAAO,EAAE;AADJ,iBApBc;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AAyBD;AAhOW;AAAA;AAAA,WAkOZ,2BAAkB;AAChB,aAAO,KAAKzE,YAAL,CAAkB0E,QAAlB,KAA+B,CAAtC;AACD;AApOW;AAAA;AAAA,WAsOZ,oBAAWC,WAAX,EAAwBd,MAAxB,EAAgC;AAC9B,UAAIe,OAAO,GAAG,IAAd;;AAEA,aAAOzF,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEvB,uBAAMyF,OAAO,CAACtC,SAAR,EAAN;;AAFuB;AAAA,sBAInBsC,OAAO,CAAC5E,YAAR,CAAqB2D,aAArB,IAAsC,IAAtC,IAA8CE,MAAM,GAAGe,OAAO,CAAC5E,YAAR,CAAqB2D,aAJzD;AAAA;AAAA;AAAA;;AAAA,sBAKf,IAAIhE,eAAJ,sDAAkEkE,MAAlE,6DAA2He,OAAO,CAAC5E,YAAR,CAAqB2D,aAAhJ,EALe;;AAAA;AAQvBlD,gBAAAA,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAN;AACAoE,gBAAAA,UAAU,GAAGD,OAAO,CAAC5E,YAAR,CAAqB8E,SAArB,IAAkC,IAAlC,IAA0CH,WAAW,KAAKC,OAAO,CAAC5E,YAAR,CAAqB8E,SAA/E,IAA4F,CAACF,OAAO,CAACT,KAAR,CAAcN,MAAd,EAAsBpD,GAAtB,CAA1G;AACAsE,gBAAAA,OAAO,GAAGH,OAAO,CAACI,eAAR,OAA8BH,UAAU,IAAID,OAAO,CAACK,SAAR,CAAkBxE,GAAlB,CAA5C,CAAV;;AAEA,oBAAIsE,OAAJ,EAAa;AACXH,kBAAAA,OAAO,CAAChE,YAAR,GAAuBH,GAAG,GAAGmE,OAAO,CAACM,cAAR,EAA7B;AACAN,kBAAAA,OAAO,CAACvE,YAAR,GAAuBuE,OAAO,CAAChE,YAAR,GAAuBgE,OAAO,CAAC5E,YAAR,CAAqBgD,OAAnE;;AAEA4B,kBAAAA,OAAO,CAAC7E,QAAR,CAAiBoF,cAAjB;AACD;;AAjBsB,mDAmBhB;AACLN,kBAAAA,UAAU,EAAVA,UADK;AAELE,kBAAAA,OAAO,EAAPA,OAFK;AAGLL,kBAAAA,QAAQ,EAAEE,OAAO,CAAC5E,YAAR,CAAqB0E;AAH1B,iBAnBgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AAyBD;AAlQW;AAAA;AAAA,WAoQZ,kBAASN,KAAT,EAAgBP,MAAhB,EAAwB;AACtB,UAAIuB,OAAO,GAAG,IAAd;;AAEA,aAAOjG,iBAAiB,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AACvB,uBAAMiG,OAAO,CAAC9C,SAAR,EAAN;;AADuB;AAEvB8C,gBAAAA,OAAO,CAAC1E,QAAR,IAAoBmD,MAApB;AACAuB,gBAAAA,OAAO,CAACzE,KAAR,IAAiBkD,MAAjB;;AAEAuB,gBAAAA,OAAO,CAACrF,QAAR,CAAiB4B,SAAjB,CAA2ByD,OAAO,CAACxD,eAAR,EAA3B;;AALuB,mDAOhB;AACLyD,kBAAAA,OAAO,EAAED,OAAO,CAAC1E;AADZ,iBAPgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAD,EAAjB,EAAP;AAWD;AAlRW;;AAAA;AAAA,GAAd;;AAqRA4E,MAAM,CAACC,OAAP,GAAiB3F,cAAjB","sourcesContent":["\"use strict\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar BottleneckError, LocalDatastore, parser;\nparser = require(\"./parser\");\nBottleneckError = require(\"./BottleneckError\");\nLocalDatastore = class LocalDatastore {\n  constructor(instance, storeOptions, storeInstanceOptions) {\n    this.instance = instance;\n    this.storeOptions = storeOptions;\n    this.clientId = this.instance._randomIndex();\n    parser.load(storeInstanceOptions, storeInstanceOptions, this);\n    this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();\n    this._running = 0;\n    this._done = 0;\n    this._unblockTime = 0;\n    this.ready = this.Promise.resolve();\n    this.clients = {};\n\n    this._startHeartbeat();\n  }\n\n  _startHeartbeat() {\n    var base;\n\n    if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {\n      return typeof (base = this.heartbeat = setInterval(() => {\n        var amount, incr, maximum, now, reservoir;\n        now = Date.now();\n\n        if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {\n          this._lastReservoirRefresh = now;\n          this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;\n\n          this.instance._drainAll(this.computeCapacity());\n        }\n\n        if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {\n          var _this$storeOptions = this.storeOptions;\n          amount = _this$storeOptions.reservoirIncreaseAmount;\n          maximum = _this$storeOptions.reservoirIncreaseMaximum;\n          reservoir = _this$storeOptions.reservoir;\n          this._lastReservoirIncrease = now;\n          incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;\n\n          if (incr > 0) {\n            this.storeOptions.reservoir += incr;\n            return this.instance._drainAll(this.computeCapacity());\n          }\n        }\n      }, this.heartbeatInterval)).unref === \"function\" ? base.unref() : void 0;\n    } else {\n      return clearInterval(this.heartbeat);\n    }\n  }\n\n  __publish__(message) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this.yieldLoop();\n      return _this.instance.Events.trigger(\"message\", message.toString());\n    })();\n  }\n\n  __disconnect__(flush) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this2.yieldLoop();\n      clearInterval(_this2.heartbeat);\n      return _this2.Promise.resolve();\n    })();\n  }\n\n  yieldLoop(t = 0) {\n    return new this.Promise(function (resolve, reject) {\n      return setTimeout(resolve, t);\n    });\n  }\n\n  computePenalty() {\n    var ref;\n    return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5000;\n  }\n\n  __updateSettings__(options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this3.yieldLoop();\n      parser.overwrite(options, options, _this3.storeOptions);\n\n      _this3._startHeartbeat();\n\n      _this3.instance._drainAll(_this3.computeCapacity());\n\n      return true;\n    })();\n  }\n\n  __running__() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this4.yieldLoop();\n      return _this4._running;\n    })();\n  }\n\n  __queued__() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this5.yieldLoop();\n      return _this5.instance.queued();\n    })();\n  }\n\n  __done__() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this6.yieldLoop();\n      return _this6._done;\n    })();\n  }\n\n  __groupCheck__(time) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this7.yieldLoop();\n      return _this7._nextRequest + _this7.timeout < time;\n    })();\n  }\n\n  computeCapacity() {\n    var maxConcurrent, reservoir;\n    var _this$storeOptions2 = this.storeOptions;\n    maxConcurrent = _this$storeOptions2.maxConcurrent;\n    reservoir = _this$storeOptions2.reservoir;\n\n    if (maxConcurrent != null && reservoir != null) {\n      return Math.min(maxConcurrent - this._running, reservoir);\n    } else if (maxConcurrent != null) {\n      return maxConcurrent - this._running;\n    } else if (reservoir != null) {\n      return reservoir;\n    } else {\n      return null;\n    }\n  }\n\n  conditionsCheck(weight) {\n    var capacity;\n    capacity = this.computeCapacity();\n    return capacity == null || weight <= capacity;\n  }\n\n  __incrementReservoir__(incr) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      var reservoir;\n      yield _this8.yieldLoop();\n      reservoir = _this8.storeOptions.reservoir += incr;\n\n      _this8.instance._drainAll(_this8.computeCapacity());\n\n      return reservoir;\n    })();\n  }\n\n  __currentReservoir__() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this9.yieldLoop();\n      return _this9.storeOptions.reservoir;\n    })();\n  }\n\n  isBlocked(now) {\n    return this._unblockTime >= now;\n  }\n\n  check(weight, now) {\n    return this.conditionsCheck(weight) && this._nextRequest - now <= 0;\n  }\n\n  __check__(weight) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      var now;\n      yield _this10.yieldLoop();\n      now = Date.now();\n      return _this10.check(weight, now);\n    })();\n  }\n\n  __register__(index, weight, expiration) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      var now, wait;\n      yield _this11.yieldLoop();\n      now = Date.now();\n\n      if (_this11.conditionsCheck(weight)) {\n        _this11._running += weight;\n\n        if (_this11.storeOptions.reservoir != null) {\n          _this11.storeOptions.reservoir -= weight;\n        }\n\n        wait = Math.max(_this11._nextRequest - now, 0);\n        _this11._nextRequest = now + wait + _this11.storeOptions.minTime;\n        return {\n          success: true,\n          wait,\n          reservoir: _this11.storeOptions.reservoir\n        };\n      } else {\n        return {\n          success: false\n        };\n      }\n    })();\n  }\n\n  strategyIsBlock() {\n    return this.storeOptions.strategy === 3;\n  }\n\n  __submit__(queueLength, weight) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      var blocked, now, reachedHWM;\n      yield _this12.yieldLoop();\n\n      if (_this12.storeOptions.maxConcurrent != null && weight > _this12.storeOptions.maxConcurrent) {\n        throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${_this12.storeOptions.maxConcurrent}`);\n      }\n\n      now = Date.now();\n      reachedHWM = _this12.storeOptions.highWater != null && queueLength === _this12.storeOptions.highWater && !_this12.check(weight, now);\n      blocked = _this12.strategyIsBlock() && (reachedHWM || _this12.isBlocked(now));\n\n      if (blocked) {\n        _this12._unblockTime = now + _this12.computePenalty();\n        _this12._nextRequest = _this12._unblockTime + _this12.storeOptions.minTime;\n\n        _this12.instance._dropAllQueued();\n      }\n\n      return {\n        reachedHWM,\n        blocked,\n        strategy: _this12.storeOptions.strategy\n      };\n    })();\n  }\n\n  __free__(index, weight) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this13.yieldLoop();\n      _this13._running -= weight;\n      _this13._done += weight;\n\n      _this13.instance._drainAll(_this13.computeCapacity());\n\n      return {\n        running: _this13._running\n      };\n    })();\n  }\n\n};\nmodule.exports = LocalDatastore;"]},"metadata":{},"sourceType":"script"}