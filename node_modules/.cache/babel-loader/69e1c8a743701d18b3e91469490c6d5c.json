{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/inspireadmin/Documents/GitHub/Project_2/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _defineProperty = require(\"/Users/inspireadmin/Documents/GitHub/Project_2/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNextKeyDef = getNextKeyDef;\nvar bracketDict;\n\n(function (bracketDict) {\n  bracketDict[\"{\"] = \"}\";\n  bracketDict[\"[\"] = \"]\";\n})(bracketDict || (bracketDict = {}));\n\nvar legacyModifiers;\n\n(function (legacyModifiers) {\n  legacyModifiers[\"alt\"] = \"alt\";\n  legacyModifiers[\"ctrl\"] = \"ctrl\";\n  legacyModifiers[\"meta\"] = \"meta\";\n  legacyModifiers[\"shift\"] = \"shift\";\n})(legacyModifiers || (legacyModifiers = {}));\n\nvar legacyKeyMap;\n/**\n * Get the next key from keyMap\n *\n * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.\n * Everything else will be interpreted as a typed character - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * Keeping the key pressed can be written as `{key>}`.\n * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.\n * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.\n * Modifiers like `{shift}` imply being kept pressed. This can be turned of per `{shift/}`.\n */\n\n(function (legacyKeyMap) {\n  legacyKeyMap[\"ctrl\"] = \"Control\";\n  legacyKeyMap[\"del\"] = \"Delete\";\n  legacyKeyMap[\"esc\"] = \"Escape\";\n  legacyKeyMap[\"space\"] = \" \";\n})(legacyKeyMap || (legacyKeyMap = {}));\n\nfunction getNextKeyDef(text, options) {\n  var _options$keyboardMap$;\n\n  var _readNextDescriptor = readNextDescriptor(text),\n      type = _readNextDescriptor.type,\n      descriptor = _readNextDescriptor.descriptor,\n      consumedLength = _readNextDescriptor.consumedLength,\n      releasePrevious = _readNextDescriptor.releasePrevious,\n      releaseSelf = _readNextDescriptor.releaseSelf,\n      repeat = _readNextDescriptor.repeat;\n\n  var keyDef = (_options$keyboardMap$ = options.keyboardMap.find(function (def) {\n    if (type === '[') {\n      var _def$code;\n\n      return ((_def$code = def.code) == null ? void 0 : _def$code.toLowerCase()) === descriptor.toLowerCase();\n    } else if (type === '{') {\n      var _def$key;\n\n      var key = mapLegacyKey(descriptor);\n      return ((_def$key = def.key) == null ? void 0 : _def$key.toLowerCase()) === key.toLowerCase();\n    }\n\n    return def.key === descriptor;\n  })) != null ? _options$keyboardMap$ : _defineProperty({\n    key: 'Unknown',\n    code: 'Unknown'\n  }, type === '[' ? 'code' : 'key', descriptor);\n  return {\n    keyDef: keyDef,\n    consumedLength: consumedLength,\n    releasePrevious: releasePrevious,\n    releaseSelf: releaseSelf,\n    repeat: repeat\n  };\n}\n\nfunction readNextDescriptor(text) {\n  var pos = 0;\n  var startBracket = text[pos] in bracketDict ? text[pos] : '';\n  pos += startBracket.length; // `foo{{bar` is an escaped char at position 3,\n  // but `foo{{{>5}bar` should be treated as `{` pressed down for 5 keydowns.\n\n  var startBracketRepeated = startBracket ? text.match(new RegExp(\"^\\\\\".concat(startBracket, \"+\")))[0].length : 0;\n  var isEscapedChar = startBracketRepeated === 2 || startBracket === '{' && startBracketRepeated > 3;\n  var type = isEscapedChar ? '' : startBracket;\n  return _objectSpread({\n    type: type\n  }, type === '' ? readPrintableChar(text, pos) : readTag(text, pos, type));\n}\n\nfunction readPrintableChar(text, pos) {\n  var descriptor = text[pos];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  return {\n    consumedLength: pos,\n    descriptor: descriptor,\n    releasePrevious: false,\n    releaseSelf: true,\n    repeat: 1\n  };\n}\n\nfunction readTag(text, pos, startBracket) {\n  var _text$slice$match, _text$slice$match$, _text$slice$match2;\n\n  var releasePreviousModifier = text[pos] === '/' ? '/' : '';\n  pos += releasePreviousModifier.length;\n  var descriptor = (_text$slice$match = text.slice(pos).match(/^\\w+/)) == null ? void 0 : _text$slice$match[0];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  var repeatModifier = (_text$slice$match$ = (_text$slice$match2 = text.slice(pos).match(/^>\\d+/)) == null ? void 0 : _text$slice$match2[0]) != null ? _text$slice$match$ : '';\n  pos += repeatModifier.length;\n  var releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';\n  pos += releaseSelfModifier.length;\n  var expectedEndBracket = bracketDict[startBracket];\n  var endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';\n\n  if (!endBracket) {\n    throw new Error(getErrorMessage([!repeatModifier && 'repeat modifier', !releaseSelfModifier && 'release modifier', \"\\\"\".concat(expectedEndBracket, \"\\\"\")].filter(Boolean).join(' or '), text[pos], text));\n  }\n\n  pos += endBracket.length;\n  return {\n    consumedLength: pos,\n    descriptor: descriptor,\n    releasePrevious: !!releasePreviousModifier,\n    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,\n    releaseSelf: hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier)\n  };\n}\n\nfunction assertDescriptor(descriptor, text, pos) {\n  if (!descriptor) {\n    throw new Error(getErrorMessage('key descriptor', text[pos], text));\n  }\n}\n\nfunction getEnumValue(f, key) {\n  return f[key];\n}\n\nfunction hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier) {\n  if (releaseSelfModifier) {\n    return releaseSelfModifier === '/';\n  }\n\n  if (repeatModifier) {\n    return false;\n  }\n\n  if (startBracket === '{' && getEnumValue(legacyModifiers, descriptor.toLowerCase())) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction mapLegacyKey(descriptor) {\n  var _getEnumValue;\n\n  return (_getEnumValue = getEnumValue(legacyKeyMap, descriptor)) != null ? _getEnumValue : descriptor;\n}\n\nfunction getErrorMessage(expected, found, text) {\n  return \"Expected \".concat(expected, \" but found \\\"\").concat(found != null ? found : '', \"\\\" in \\\"\").concat(text, \"\\\"\\n    See https://github.com/testing-library/user-event/blob/main/README.md#keyboardtext-options\\n    for more information about how userEvent parses your input.\");\n}","map":{"version":3,"sources":["/Users/inspireadmin/Documents/GitHub/Project_2/node_modules/@testing-library/user-event/dist/keyboard/getNextKeyDef.js"],"names":["Object","defineProperty","exports","value","getNextKeyDef","bracketDict","legacyModifiers","legacyKeyMap","text","options","_options$keyboardMap$","readNextDescriptor","type","descriptor","consumedLength","releasePrevious","releaseSelf","repeat","keyDef","keyboardMap","find","def","_def$code","code","toLowerCase","_def$key","key","mapLegacyKey","pos","startBracket","length","startBracketRepeated","match","RegExp","isEscapedChar","readPrintableChar","readTag","assertDescriptor","_text$slice$match","_text$slice$match$","_text$slice$match2","releasePreviousModifier","slice","repeatModifier","releaseSelfModifier","expectedEndBracket","endBracket","Error","getErrorMessage","filter","Boolean","join","Math","max","Number","substr","hasReleaseSelf","getEnumValue","f","_getEnumValue","expected","found"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNextKeyDef = getNextKeyDef;\nvar bracketDict;\n\n(function (bracketDict) {\n  bracketDict[\"{\"] = \"}\";\n  bracketDict[\"[\"] = \"]\";\n})(bracketDict || (bracketDict = {}));\n\nvar legacyModifiers;\n\n(function (legacyModifiers) {\n  legacyModifiers[\"alt\"] = \"alt\";\n  legacyModifiers[\"ctrl\"] = \"ctrl\";\n  legacyModifiers[\"meta\"] = \"meta\";\n  legacyModifiers[\"shift\"] = \"shift\";\n})(legacyModifiers || (legacyModifiers = {}));\n\nvar legacyKeyMap;\n/**\n * Get the next key from keyMap\n *\n * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.\n * Everything else will be interpreted as a typed character - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * Keeping the key pressed can be written as `{key>}`.\n * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.\n * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.\n * Modifiers like `{shift}` imply being kept pressed. This can be turned of per `{shift/}`.\n */\n\n(function (legacyKeyMap) {\n  legacyKeyMap[\"ctrl\"] = \"Control\";\n  legacyKeyMap[\"del\"] = \"Delete\";\n  legacyKeyMap[\"esc\"] = \"Escape\";\n  legacyKeyMap[\"space\"] = \" \";\n})(legacyKeyMap || (legacyKeyMap = {}));\n\nfunction getNextKeyDef(text, options) {\n  var _options$keyboardMap$;\n\n  const {\n    type,\n    descriptor,\n    consumedLength,\n    releasePrevious,\n    releaseSelf,\n    repeat\n  } = readNextDescriptor(text);\n  const keyDef = (_options$keyboardMap$ = options.keyboardMap.find(def => {\n    if (type === '[') {\n      var _def$code;\n\n      return ((_def$code = def.code) == null ? void 0 : _def$code.toLowerCase()) === descriptor.toLowerCase();\n    } else if (type === '{') {\n      var _def$key;\n\n      const key = mapLegacyKey(descriptor);\n      return ((_def$key = def.key) == null ? void 0 : _def$key.toLowerCase()) === key.toLowerCase();\n    }\n\n    return def.key === descriptor;\n  })) != null ? _options$keyboardMap$ : {\n    key: 'Unknown',\n    code: 'Unknown',\n    [type === '[' ? 'code' : 'key']: descriptor\n  };\n  return {\n    keyDef,\n    consumedLength,\n    releasePrevious,\n    releaseSelf,\n    repeat\n  };\n}\n\nfunction readNextDescriptor(text) {\n  let pos = 0;\n  const startBracket = text[pos] in bracketDict ? text[pos] : '';\n  pos += startBracket.length; // `foo{{bar` is an escaped char at position 3,\n  // but `foo{{{>5}bar` should be treated as `{` pressed down for 5 keydowns.\n\n  const startBracketRepeated = startBracket ? text.match(new RegExp(`^\\\\${startBracket}+`))[0].length : 0;\n  const isEscapedChar = startBracketRepeated === 2 || startBracket === '{' && startBracketRepeated > 3;\n  const type = isEscapedChar ? '' : startBracket;\n  return {\n    type,\n    ...(type === '' ? readPrintableChar(text, pos) : readTag(text, pos, type))\n  };\n}\n\nfunction readPrintableChar(text, pos) {\n  const descriptor = text[pos];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  return {\n    consumedLength: pos,\n    descriptor,\n    releasePrevious: false,\n    releaseSelf: true,\n    repeat: 1\n  };\n}\n\nfunction readTag(text, pos, startBracket) {\n  var _text$slice$match, _text$slice$match$, _text$slice$match2;\n\n  const releasePreviousModifier = text[pos] === '/' ? '/' : '';\n  pos += releasePreviousModifier.length;\n  const descriptor = (_text$slice$match = text.slice(pos).match(/^\\w+/)) == null ? void 0 : _text$slice$match[0];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  const repeatModifier = (_text$slice$match$ = (_text$slice$match2 = text.slice(pos).match(/^>\\d+/)) == null ? void 0 : _text$slice$match2[0]) != null ? _text$slice$match$ : '';\n  pos += repeatModifier.length;\n  const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';\n  pos += releaseSelfModifier.length;\n  const expectedEndBracket = bracketDict[startBracket];\n  const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';\n\n  if (!endBracket) {\n    throw new Error(getErrorMessage([!repeatModifier && 'repeat modifier', !releaseSelfModifier && 'release modifier', `\"${expectedEndBracket}\"`].filter(Boolean).join(' or '), text[pos], text));\n  }\n\n  pos += endBracket.length;\n  return {\n    consumedLength: pos,\n    descriptor,\n    releasePrevious: !!releasePreviousModifier,\n    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,\n    releaseSelf: hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier)\n  };\n}\n\nfunction assertDescriptor(descriptor, text, pos) {\n  if (!descriptor) {\n    throw new Error(getErrorMessage('key descriptor', text[pos], text));\n  }\n}\n\nfunction getEnumValue(f, key) {\n  return f[key];\n}\n\nfunction hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier) {\n  if (releaseSelfModifier) {\n    return releaseSelfModifier === '/';\n  }\n\n  if (repeatModifier) {\n    return false;\n  }\n\n  if (startBracket === '{' && getEnumValue(legacyModifiers, descriptor.toLowerCase())) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction mapLegacyKey(descriptor) {\n  var _getEnumValue;\n\n  return (_getEnumValue = getEnumValue(legacyKeyMap, descriptor)) != null ? _getEnumValue : descriptor;\n}\n\nfunction getErrorMessage(expected, found, text) {\n  return `Expected ${expected} but found \"${found != null ? found : ''}\" in \"${text}\"\n    See https://github.com/testing-library/user-event/blob/main/README.md#keyboardtext-options\n    for more information about how userEvent parses your input.`;\n}"]},"metadata":{},"sourceType":"script"}