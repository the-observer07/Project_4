{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/inspireadmin/Documents/GitHub/Project_2/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _asyncToGenerator = require(\"/Users/inspireadmin/Documents/GitHub/Project_2/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeImplementation = typeImplementation;\n\nvar _utils = require(\"../utils\");\n\nvar _click = require(\"../click\");\n\nvar _keyboard = require(\"../keyboard\");\n\nfunction typeImplementation(_x, _x2, _x3) {\n  return _typeImplementation.apply(this, arguments);\n}\n\nfunction _typeImplementation() {\n  _typeImplementation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(element, text, _ref) {\n    var delay, _ref$skipClick, skipClick, _ref$skipAutoClose, skipAutoClose, _ref$initialSelection, initialSelectionStart, _ref$initialSelection2, initialSelectionEnd, currentElement, value, _ref2, selectionStart, selectionEnd, _ref3, promise, releaseAllKeys;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            delay = _ref.delay, _ref$skipClick = _ref.skipClick, skipClick = _ref$skipClick === void 0 ? false : _ref$skipClick, _ref$skipAutoClose = _ref.skipAutoClose, skipAutoClose = _ref$skipAutoClose === void 0 ? false : _ref$skipAutoClose, _ref$initialSelection = _ref.initialSelectionStart, initialSelectionStart = _ref$initialSelection === void 0 ? undefined : _ref$initialSelection, _ref$initialSelection2 = _ref.initialSelectionEnd, initialSelectionEnd = _ref$initialSelection2 === void 0 ? undefined : _ref$initialSelection2;\n\n            if (!element.disabled) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 3:\n            if (!skipClick) (0, _click.click)(element); // The focused element could change between each event, so get the currently active element each time\n\n            currentElement = function currentElement() {\n              return (0, _utils.getActiveElement)(element.ownerDocument);\n            }; // by default, a new element has its selection start and end at 0\n            // but most of the time when people call \"type\", they expect it to type\n            // at the end of the current input value. So, if the selection start\n            // and end are both the default of 0, then we'll go ahead and change\n            // them to the length of the current value.\n            // the only time it would make sense to pass the initialSelectionStart or\n            // initialSelectionEnd is if you have an input with a value and want to\n            // explicitly start typing with the cursor at 0. Not super common.\n\n\n            value = (0, _utils.getValue)(currentElement());\n            _ref2 = (0, _utils.getSelectionRange)(element), selectionStart = _ref2.selectionStart, selectionEnd = _ref2.selectionEnd;\n\n            if (value != null && (selectionStart === null || selectionStart === 0) && (selectionEnd === null || selectionEnd === 0)) {\n              (0, _utils.setSelectionRange)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n            }\n\n            _ref3 = (0, _keyboard.keyboardImplementationWrapper)(text, {\n              delay: delay,\n              document: element.ownerDocument\n            }), promise = _ref3.promise, releaseAllKeys = _ref3.releaseAllKeys;\n\n            if (!(delay > 0)) {\n              _context.next = 12;\n              break;\n            }\n\n            _context.next = 12;\n            return promise;\n\n          case 12:\n            if (!skipAutoClose) {\n              releaseAllKeys();\n            } // eslint-disable-next-line consistent-return -- we need to return the internal Promise so that it is catchable if we don't await\n\n\n            return _context.abrupt(\"return\", promise);\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _typeImplementation.apply(this, arguments);\n}","map":{"version":3,"sources":["/Users/inspireadmin/Documents/GitHub/Project_2/node_modules/@testing-library/user-event/dist/type/typeImplementation.js"],"names":["Object","defineProperty","exports","value","typeImplementation","_utils","require","_click","_keyboard","element","text","delay","skipClick","skipAutoClose","initialSelectionStart","undefined","initialSelectionEnd","disabled","click","currentElement","getActiveElement","ownerDocument","getValue","getSelectionRange","selectionStart","selectionEnd","setSelectionRange","length","keyboardImplementationWrapper","document","promise","releaseAllKeys"],"mappings":"AAAA;;;;;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,kBAAR,GAA6BA,kBAA7B;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,UAAD,CAApB;;AAEA,IAAIC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAApB;;AAEA,IAAIE,SAAS,GAAGF,OAAO,CAAC,aAAD,CAAvB;;SAEeF,kB;;;;;iFAAf,iBAAkCK,OAAlC,EAA2CC,IAA3C;AAAA;;AAAA;AAAA;AAAA;AAAA;AACEC,YAAAA,KADF,QACEA,KADF,wBAEEC,SAFF,EAEEA,SAFF,+BAEc,KAFd,6CAGEC,aAHF,EAGEA,aAHF,mCAGkB,KAHlB,oDAIEC,qBAJF,EAIEA,qBAJF,sCAI0BC,SAJ1B,wDAKEC,mBALF,EAKEA,mBALF,uCAKwBD,SALxB;;AAAA,iBASMN,OAAO,CAACQ,QATd;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAUE,gBAAI,CAACL,SAAL,EAAgB,CAAC,GAAGL,MAAM,CAACW,KAAX,EAAkBT,OAAlB,EAVlB,CAU8C;;AAEtCU,YAAAA,cAZR,GAYyB,SAAjBA,cAAiB;AAAA,qBAAM,CAAC,GAAGd,MAAM,CAACe,gBAAX,EAA6BX,OAAO,CAACY,aAArC,CAAN;AAAA,aAZzB,EAYoF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGMlB,YAAAA,KAtBR,GAsBgB,CAAC,GAAGE,MAAM,CAACiB,QAAX,EAAqBH,cAAc,EAAnC,CAtBhB;AAAA,oBA0BM,CAAC,GAAGd,MAAM,CAACkB,iBAAX,EAA8Bd,OAA9B,CA1BN,EAwBIe,cAxBJ,SAwBIA,cAxBJ,EAyBIC,YAzBJ,SAyBIA,YAzBJ;;AA4BE,gBAAItB,KAAK,IAAI,IAAT,KAAkBqB,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,CAAhE,MAAuEC,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,CAAjH,CAAJ,EAAyH;AACvH,eAAC,GAAGpB,MAAM,CAACqB,iBAAX,EAA8BP,cAAc,EAA5C,EAAgDL,qBAAqB,IAAI,IAAzB,GAAgCA,qBAAhC,GAAwDX,KAAK,CAACwB,MAA9G,EAAsHX,mBAAmB,IAAI,IAAvB,GAA8BA,mBAA9B,GAAoDb,KAAK,CAACwB,MAAhL;AACD;;AA9BH,oBAmCM,CAAC,GAAGnB,SAAS,CAACoB,6BAAd,EAA6ClB,IAA7C,EAAmD;AACrDC,cAAAA,KAAK,EAALA,KADqD;AAErDkB,cAAAA,QAAQ,EAAEpB,OAAO,CAACY;AAFmC,aAAnD,CAnCN,EAiCIS,OAjCJ,SAiCIA,OAjCJ,EAkCIC,cAlCJ,SAkCIA,cAlCJ;;AAAA,kBAwCMpB,KAAK,GAAG,CAxCd;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAyCUmB,OAzCV;;AAAA;AA4CE,gBAAI,CAACjB,aAAL,EAAoB;AAClBkB,cAAAA,cAAc;AACf,aA9CH,CA8CI;;;AA9CJ,6CAiDSD,OAjDT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeImplementation = typeImplementation;\n\nvar _utils = require(\"../utils\");\n\nvar _click = require(\"../click\");\n\nvar _keyboard = require(\"../keyboard\");\n\nasync function typeImplementation(element, text, {\n  delay,\n  skipClick = false,\n  skipAutoClose = false,\n  initialSelectionStart = undefined,\n  initialSelectionEnd = undefined\n}) {\n  // TODO: properly type guard\n  // we use this workaround for now to prevent changing behavior\n  if (element.disabled) return;\n  if (!skipClick) (0, _click.click)(element); // The focused element could change between each event, so get the currently active element each time\n\n  const currentElement = () => (0, _utils.getActiveElement)(element.ownerDocument); // by default, a new element has its selection start and end at 0\n  // but most of the time when people call \"type\", they expect it to type\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitly start typing with the cursor at 0. Not super common.\n\n\n  const value = (0, _utils.getValue)(currentElement());\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n\n  if (value != null && (selectionStart === null || selectionStart === 0) && (selectionEnd === null || selectionEnd === 0)) {\n    (0, _utils.setSelectionRange)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n  }\n\n  const {\n    promise,\n    releaseAllKeys\n  } = (0, _keyboard.keyboardImplementationWrapper)(text, {\n    delay,\n    document: element.ownerDocument\n  });\n\n  if (delay > 0) {\n    await promise;\n  }\n\n  if (!skipAutoClose) {\n    releaseAllKeys();\n  } // eslint-disable-next-line consistent-return -- we need to return the internal Promise so that it is catchable if we don't await\n\n\n  return promise;\n}"]},"metadata":{},"sourceType":"script"}